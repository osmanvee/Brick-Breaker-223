class PlayedGame {

  // State Machine
  
  playStatus {
    Ready {
      entry / { doSetup(); }
      play -> Moving;
    }
    Moving {
      pause -> Paused;
      move [hitPaddle()] / { doHitPaddleOrWall(); } -> Moving;
      move [isOutOfBoundsAndLastLife()] / { doOutOfBounds(); } -> GameOver;
      move [isOutOfBounds()] / { doOutOfBounds(); } -> Paused;
      move [hitLastBlockAndLastLevel()] / { doHitBlock(); } -> GameOver;
      move [hitLastBlock()] / { doHitBlockNextLevel(); } -> Ready;
      move [hitBlock()] / { doHitBlock(); } -> Moving;
      move [hitWall()] / { doHitPaddleOrWall(); } -> Moving;
      move / { doHitNothingAndNotOutOfBounds(); } -> Moving;
    }
    Paused {
      play -> Moving;
    }
    GameOver {
      entry / { doGameOver(); }
    }
  }
  
  // Guards
  
  private boolean hitPaddle() {
    // TODO implement
    return false;
  }

  private boolean isOutOfBoundsAndLastLife() {
    // TODO implement
    return false;
  }
  
  private boolean isOutOfBounds() {
    // TODO implement
    return false;
  }
  
  private boolean hitLastBlockAndLastLevel() {
    
    Game game = this.getGame(); 
	int nrLevels = game.numberOfLevels(); 
	
	this.setBounce(null); 
	
	if(nrLevels == currentLevel) {
		int nrBlocks = numberOfBlocks(); 
		if(nrBlocks == 1) {
			PlayedBlockAssignment block = this.getBlock(0); 
			BouncePoint bp = calculateBouncePointBlock(block); 
			setBounce(bp); 
			return true; 
		}
	}
    return false;
  }
  
  private boolean hitLastBlock(){

	int nrBlocks = numberOfBlocks(); 
	setBounce(null); 
	
	if(nrBlocks == 1) {
		PlayedBlockAssignment block = this.getBlock(0); 
		BouncePoint bp = null; 
		
		try{
			bp = calculateBouncePointBlock(block);
		}
		catch(NullPointerException e) {
			return false; //no bounce point found. 
		}
		setBounce(bp); 
		return true; 
	}
    return false;
    
  }
  
  private boolean hitBlock() {
	   int nrBlocks = numberOfBlocks();
	   setBounce(null); 
	   
	   for(int index = 0; index < nrBlocks - 1; index++) {
		   PlayedBlockAssignment block = getBlock(index); 
		   
		   BouncePoint bp = null; 
		   try {
			   bp = calculateBouncePointBlock(block); 
		   }
		   catch(NullPointerException e) {
			   //what happens if its null?
		   }
		   
		   bounce = getBounce(); 
		   boolean closer = isCloser(bp, bounce); 
		   
		   if(closer) setBounce(bp); 
		  
	   }
	   return (getBounce()!=null); 
  }
  
  private boolean hitWall() {
    // TODO implement
    return false;
  }
  
  // Actions
  
  private void doSetup() {
    // TODO implement
  }
  
  private void doHitPaddleOrWall() {
    // TODO implement
  }

  private void doOutOfBounds() {
    // TODO implement
  }

  private void doHitBlock() {
       int score = getScore(); 
	   bounce = getBounce(); 
	   PlayedBlockAssignment pblock = bounce.getHitBlock(); 
	   
	   Block block = pblock.getBlock(); 
	   int bscore = block.getPoints();
	   
	   this.setScore(score + bscore); 
	   pblock.delete();
	   bounceBall(); 
  }

  private void doHitBlockNextLevel() {
   	   doHitBlock(); 
	   int level = getCurrentLevel(); 
	   setCurrentLevel(level+1); 
	   
	   setCurrentPaddleLength(getGame().getPaddle().getMaxPaddleLength() -
			   (getGame().getPaddle().getMaxPaddleLength() - getGame().getPaddle().getMinPaddleLength())/
			   (getGame().numberOfLevels() - 1) * (getCurrentLevel() - 1));
	   
	   setWaitTime(INITIAL_WAIT_TIME * Math.pow(getGame().getBall().getBallSpeedIncreaseFactor(), 
			   (getCurrentLevel() - 1))); 
  }

  private void doHitNothingAndNotOutOfBounds() {
    // TODO implement
  }

  private void doGameOver() {
    // TODO implement
  }
  
  
  // Helper methods 
  private BouncePoint calculateBouncePointPaddle(){
  	int x=(int)getCurrentPaddleX();
  	int y=(int)getCurrentPaddleY();
  	int length=(int)getCurrentPaddleLength();
  	int radius=Ball.BALL_DIAMETER/2;
  	int width=Paddle.PADDLE_WIDTH;
  	Rectangle2D A=new Rectangle2D.Float(x,y-radius,length,width );
  	Rectangle2D B=new Rectangle2D.Float(x-radius,y,length,width );
  	Rectangle2D C=new Rectangle2D.Float(x+length,y,length,width );
  	Rectangle2D F=new Rectangle2D.Float(x+length,y-radius,length,width);
  	Rectangle2D E=new Rectangle2D.Float(x-radius,y-radius,length,width);
  	
  	Line2D segment=new Line2D.Float((float)getCurrentBallX(),(float)getCurrentBallY(),
  			(float)(getCurrentBallX()+getBallDirectionX()),(float)(getCurrentBallY()+getBallDirectionY()));
  	
  	if(segment.intersects(A)){
  		
  	}else if(segment.intersects(B)){
  	
  	}else if(segment.intersects(C)){
  	
  	}else if(segment.intersects(F)){
  	
  	}else if(segment.intersects(E)){
  	
  	}
  	return null;
  }
  
  private BouncePoint calculateBouncePointWall(){
  	return null;
  }
  
  private void bounceBall(){
  
  }
  
  private BouncePoint calculateBouncePointBlock(PlayedBlockAssignment block){
  	return null;
  }
  
   private boolean isCloser(BouncePoint first, BouncePoint second) {
	    double ballPosX = getCurrentBallX(); 
	    double ballPosY = getCurrentBallY(); 
	    
	    if(first == null) {
	    	return false; 
	    }
	    
	    if(second == null) {
	    	return true; 
	    }
	    
	    //we will use euclidean distance to see which is closer 
	    double distToFirst = Math.sqrt(Math.pow((first.getX() - ballPosX),2) + 
	    							   Math.pow(first.getY() - ballPosY, 2));

	    double distToSecond = Math.sqrt(Math.pow((second.getX() - ballPosX),2) + 
				   Math.pow(second.getY() - ballPosY, 2));
	    
	    if(distToFirst <= distToSecond) {
	    	return true; 
	    }
	    return false; 
	  }



	  }