class PlayedGame {

  // State Machine
  
  playStatus {
    Ready {
      entry / { doSetup(); }
      play -> Moving;
    }
    Moving {
      pause -> Paused;
      move [hitPaddle()] / { doHitPaddleOrWall(); } -> Moving;
      move [isOutOfBoundsAndLastLife()] / { doOutOfBounds(); } -> GameOver;
      move [isOutOfBounds()] / { doOutOfBounds(); } -> Paused;
      move [hitLastBlockAndLastLevel()] / { doHitBlock(); } -> GameOver;
      move [hitLastBlock()] / { doHitBlockNextLevel(); } -> Ready;
      move [hitBlock()] / { doHitBlock(); } -> Moving;
      move [hitWall()] / { doHitPaddleOrWall(); } -> Moving;
      move / { doHitNothingAndNotOutOfBounds(); } -> Moving;
    }
    Paused {
      play -> Moving;
    }
    GameOver {
      entry / { doGameOver(); }
    }
  }
  
  // Guards
  
  private boolean hitPaddle() {
   BouncePoint bp=calculateBouncePointPaddle();
    setBounce(bp);
    return bp!=null;
  }

  private boolean isOutOfBoundsAndLastLife() {
   boolean outOfBounds = false;
     if (this.NR_LIVES ==1) {
    	outOfBounds = isBallOutOfBounds();
    }
    return outOfBounds;
  }
  
  private boolean isOutOfBounds() {
     Boolean outOfBounds = isBallOutOfBounds();
    
    return outOfBounds;
  }
   private boolean isBallOutOfBounds() {
	   boolean outofbounds= false;
	   if (this.getCurrentBallY() + this.getBallDirectionY() + 5 > 355) {
		   outofbounds=true;
	   }
	   return outofbounds;
   }
  
   private boolean hitLastBlockAndLastLevel(){
    Game game = this.getGame(); 
	int nrLevels = game.numberOfLevels(); 
	
	this.setBounce(null); 
	
	if(nrLevels == currentLevel) {
		int nrBlocks = numberOfBlocks(); 
		if(nrBlocks == 1) {
			PlayedBlockAssignment block = this.getBlock(0); 
			BouncePoint bp = calculateBouncePointBlock(block); 
			setBounce(bp); 
			return (bp!=null); 
		}
	}
    return false;
  }
  
    private boolean hitLastBlock(){
    int nrBlocks = numberOfBlocks(); 
	setBounce(null); 
	
	if(nrBlocks == 1) {
		PlayedBlockAssignment block = this.getBlock(0); 
		BouncePoint bp = calculateBouncePointBlock(block);
		setBounce(bp); 
		return (bp!=null); 
	}
    return false;
  }
    
   private boolean hitBlock(){
    int nrBlocks = numberOfBlocks();
	   setBounce(null); 
	   
	   for(int index = 0; index < nrBlocks - 1; index++) {
		   PlayedBlockAssignment block = getBlock(index); 
		   
		   BouncePoint bp = calculateBouncePointBlock(block); 		   
		   bounce = getBounce(); 
		   boolean closer = isCloser(bp, bounce); 
		   if(closer) setBounce(bp); 
	   }
	   return (getBounce()!=null);
  }
    
  private boolean hitWall() {
    BouncePoint bp=calculateBouncePointWall();
    setBounce(bp);
    return bp!=null;
  }
  
  // Actions
  
  //TODO: this method has to be implemented. 	
   private void doSetup(){
	   
	   resetCurrentBallX(); 
	   resetCurrentBallY(); 
	   resetBallDirectionX(); 
	   resetBallDirectionY(); 
	   resetCurrentPaddleX(); 
	   
	   Game game = getGame(); 
	   
	   Level level = game.getLevel(currentLevel - 1); 
	   List<BlockAssignment> assignments = level.getBlockAssignments(); 
	   
	   for(BlockAssignment a : assignments) {
		   PlayedBlockAssignment pblock = new PlayedBlockAssignment
				   (game.WALL_PADDING + (Block.SIZE + game.COLUMNS_PADDING)*
						   (a.getGridHorizontalPosition() - 1), game.WALL_PADDING +
						   (Block.SIZE + game.ROW_PADDING)*(a.getGridVerticalPosition() - 1),
						   a.getBlock(), this); 
	   }
	   
	   while(numberOfBlocks() < game.getNrBlocksPerLevel()) {
		   //pick x and y randomly: 
		   //first pick a grid position randomly 
		   //if its already taken, try next position starting from the randomly 
		   
		   int x = 0; 
		   int y = 0; 
		   
		   PlayedBlockAssignment pblock = new PlayedBlockAssignment
				   (x, y, game.getRandomBlock(), this); 
	   }
	   
  }

  
  private void doHitPaddleOrWall() {
     bounceBall();
  }

  private void doOutOfBounds() {
    this.setLives(lives-1);
    this.resetCurrentBallX();
    this.resetCurrentBallY();
    this.resetBallDirectionX();
    this.resetBallDirectionY();
    this.resetCurrentPaddleX();
  }

  private void doHitBlock() {
       int score = getScore(); 
	   bounce = getBounce(); 
	   PlayedBlockAssignment pblock = bounce.getHitBlock(); 
	   
	   Block block = pblock.getBlock(); 
	   int bscore = block.getPoints();
	   
	   this.setScore(score + bscore); 
	   pblock.delete();
	   bounceBall(); 
  }

  private void doHitBlockNextLevel() {
   	   doHitBlock(); 
	   int level = getCurrentLevel(); 
	   setCurrentLevel(level+1); 
	   
	   setCurrentPaddleLength(getGame().getPaddle().getMaxPaddleLength() -
			   (getGame().getPaddle().getMaxPaddleLength() - getGame().getPaddle().getMinPaddleLength())/
			   (getGame().numberOfLevels() - 1) * (getCurrentLevel() - 1));
	   
	   setWaitTime(INITIAL_WAIT_TIME * Math.pow(getGame().getBall().getBallSpeedIncreaseFactor(), 
			   (getCurrentLevel() - 1))); 
  }

  private void doHitNothingAndNotOutOfBounds() {
	  double x = getCurrentBallX();
	  double y = getCurrentBallY();
	  double dx = getBallDirectionX();
	  double dy = getBallDirectionY();
	  setCurrentBallX(x + dx);
	  setCurrentBallY(y + dy);
  }
  private void doGameOver() {
    Block223 block223 = this.getBlock223();
	   Player p = this.getPlayer();
	   
	   if (p != null) {
		   Game game = this.getGame();
		   HallOfFameEntry hof = new HallOfFameEntry(this.score, p.toString(), p, game, block223);
		   game.setMostRecentEntry(hof);
	   }
	   this.delete();
  }
  
  
  // Helper methods 
  private BouncePoint calculateBouncePointPaddle(){
  	int x=(int)getCurrentPaddleX();
  	int y=(int)getCurrentPaddleY();
  	int length=(int)getCurrentPaddleLength();
  	int radius=Ball.BALL_DIAMETER/2;
  	int width=Paddle.PADDLE_WIDTH;
  	Rectangle2D rectA=new Rectangle2D.Float(x,y-radius,length,width );
  	Rectangle2D rectB=new Rectangle2D.Float(x-radius,y,length,width );
  	Rectangle2D rectC=new Rectangle2D.Float(x+length,y,length,width );
  	Rectangle2D rectF=new Rectangle2D.Float(x+length,y-radius,length,width);
  	Rectangle2D rectE=new Rectangle2D.Float(x-radius,y-radius,length,width);
   	float currentX=(float)getCurrentBallX();
    float currentY=(float)getCurrentBallY();
   	float dX=(float)getBallDirectionX();
    float dY=(float)getBallDirectionY();
  	Line2D segment=new Line2D.Float(currentX,currentY,currentX+dX,currentY+dY);
  	
  	if(segment.intersects(rectA)){
  		if(dX==0){
  			return new BouncePoint(currentX,y-radius,BounceDirection.FLIP_Y);
  		}else{
  			float a=dY/dX;
  			float b=currentY-a*currentX;
  			float bounceY=y-radius;
  			float bounceX=(bounceY-b)/a;
  			return new BouncePoint(bounceX,bounceY,BounceDirection.FLIP_Y);
  		}
  	}else if(segment.intersects(rectB)){
  		if(dX!=0){
  			float a=dY/dX;
  			float b=currentY-a*currentX;
  			float bounceX=x-radius;
  			float bounceY=a*bounceX+b;
  			return new BouncePoint(bounceX,bounceY,BounceDirection.FLIP_X);
  		}
  	}else if(segment.intersects(rectC)){
  		if(dX!=0){
  			float a=dY/dX;
  			float b=currentY-a*currentX;
  			float bounceX=x-radius;
  			float bounceY=a*bounceX+b;
  			return new BouncePoint(bounceX,bounceY,BounceDirection.FLIP_X);
  		}
  	}else if(segment.intersects(rectE)){
  		if(dX!=0){
  			float a=dY/dX;
  			float b=currentY-a*currentX;
  			double A=1+Math.pow(a,2);
  			double B=2*a*(b-y)-2*x;
  			double C=Math.pow(x,2)+Math.pow(b-y,2)-radius;
  			double delta=Math.sqrt(Math.pow(B,2)-4*A*C);
  			double X=-B-delta;
  			double Y=a*X+b;
  			if (dX<0){
  				return new BouncePoint(X,Y, BounceDirection.FLIP_Y);
  			}else{
  				return new BouncePoint(X,Y, BounceDirection.FLIP_X);
  			}
  		}
  	}else if(segment.intersects(rectF)){
  		if(dX!=0){
  			float a=dY/dX;
  			float b=currentY-a*currentX;
  			double A=1+Math.pow(a,2);
  			double B=2*a*(b-y)-2*(x+length);
  			double C=Math.pow((x+length),2)+Math.pow(b-y,2)-radius;
  			double delta=Math.sqrt(Math.pow(B,2)-4*A*C);
  			double X=-B+delta;
  			double Y=a*X+b;
  			if (dX<0){
  				return new BouncePoint(X,Y, BounceDirection.FLIP_X);
  			}else{
  				return new BouncePoint(X,Y, BounceDirection.FLIP_Y);
  			}
  		}
  	}
  	return null;
  }
  
  private BouncePoint calculateBouncePointWall(){
  	float currentX=(float)getCurrentBallX();
   float currentY=(float)getCurrentBallY();
   float dX=(float)getBallDirectionX();
   float dY=(float)getBallDirectionY();
   
   if(currentY+dY<=5){
   		if(currentX+dX<=5){
   			return  new BouncePoint(5.0f,5.0f, BounceDirection.FLIP_BOTH);
   		}else if(currentX+dX<=385){
   			return  new BouncePoint(385.0f,5.0f, BounceDirection.FLIP_BOTH);
   		}else{
   			if(dX!=0){
   				float a=dY/dX;
  				float b=currentY-a*currentX;
  				float bounceY=5.0f;
  				float bounceX=(bounceY-b)/a;
  				return new BouncePoint(bounceX,bounceY,BounceDirection.FLIP_Y);
  			}else{
  				return new BouncePoint(currentX, 5.0f, BounceDirection.FLIP_Y);
  			}
   		}
    }
    
    if(currentX+dX<=5){
    	if(dX!=0){
   				float a=dY/dX;
  				float b=currentY-a*currentX;
  				float bounceX=5.0f;
  				float bounceY=a*bounceX+b;
  				
  				return new BouncePoint(bounceX,bounceY,BounceDirection.FLIP_X);
  		}
    }
    if(currentX+dX>=385){
    	if(dX!=0){
   				float a=dY/dX;
  				float b=currentY-a*currentX;
  				float bounceX=385.0f;
  				float bounceY=a*bounceX+b;
  				
  				return new BouncePoint(bounceX,bounceY,BounceDirection.FLIP_X);
  		}
    }
  	return null;
  }
  
  private void bounceBall(){
  	BouncePoint bp=getBounce();
  	double currentX=getCurrentBallX();
  	double currentY=getCurrentBallY();
  	double incomingX=bp.getX()-currentX;
  	double incomingY=bp.getY()-currentY;
  	double remainingX=getBallDirectionX()-incomingX;
  	double remainingY=getBallDirectionY()-incomingX;
  	if(remainingX==0 && remainingY==0){
  		setCurrentBallX(bp.getX());
  		setCurrentBallY(bp.getY());
  	}else{
  		double newDirX,newDirY,newX,newY;
  		if(bp.getDirection()==BounceDirection.FLIP_X){
  			 newDirX=-getBallDirectionX();
  			 newDirY=getBallDirectionY()+sign(getBallDirectionY())*0.1*Math.abs(newDirX);
  			 newX=bp.getX()+remainingX*newDirX/getBallDirectionX();
  			 newY=bp.getY()+remainingY*newDirY/getBallDirectionY();
  		}else if (bp.getDirection()==BounceDirection.FLIP_Y){
  			 newDirY=-getBallDirectionY();
  			 newDirX=getBallDirectionX()+sign(getBallDirectionX())*0.1*Math.abs(newDirY);
  			 newY=bp.getY()+remainingY*newDirY/getBallDirectionY();
  			 newX=bp.getY()+remainingX*newDirX/getBallDirectionX();	
  		}else{
  			 newDirX=-getBallDirectionX();
  			 newDirY=-getBallDirectionY();
  			 newX=bp.getX()+remainingX*newDirX/getBallDirectionX();
  			 newY=bp.getY()+remainingY*newDirY/getBallDirectionY();
  		}
  			setCurrentBallX(newX);
  			setCurrentBallY(newY);
  			setBallDirectionX(newDirX);
  			setBallDirectionY(newDirY);
  	}
  	
  }
  private int sign(double val){
		if(val>=0){
			return 1;
		}  
		return -1;
  
  }
  private BouncePoint calculateBouncePointBlock(PlayedBlockAssignment block){
  	return null;
  }
  
   private boolean isCloser(BouncePoint first, BouncePoint second) {
	    double ballPosX = getCurrentBallX(); 
	    double ballPosY = getCurrentBallY(); 
	    
	    if(first == null) {
	    	return false; 
	    }
	    
	    if(second == null) {
	    	return true; 
	    }
	    
	    //we will use euclidean distance to see which is closer 
	    double distToFirst = Math.sqrt(Math.pow((first.getX() - ballPosX),2) + 
	    							   Math.pow(first.getY() - ballPosY, 2));

	    double distToSecond = Math.sqrt(Math.pow((second.getX() - ballPosX),2) + 
				   Math.pow(second.getY() - ballPosY, 2));
	    
	    if(distToFirst <= distToSecond) {
	    	return true; 
	    }
	    return false; 
	  }



	  }